{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RebindableSyntax  #-}
{-# LANGUAGE UnicodeSyntax     #-}
module MathPrelude.Constructions.Quotient
  ( module MathPrelude.Classes.EuclideanDomain
  , Quotient(..)
  , proj
  , liftQ, liftQ2, liftQ2'
  )  where

import MathPrelude
import qualified Prelude                             as P

-- From math-prelude
import           MathPrelude.Classes.EuclideanDomain

-- From math-calculus
import           MathPrelude.Calculus.Derivation


------------------------------
--- Quotient
------------------------------
-- | A representation of a ring quotiented by an ideal generated by the element "modulus". Can be quite un-type-safe, and throws errors when operations attempt to work with value from different quotients (different moduli). A modulus of Nothing represents an element of the ring, which will be projected to the appropriate quotient when required (needed to make one and zero work, etc).
data Quotient a = Quotient { modulus ∷ Maybe a, element ∷ a}

------------------------------
---- Methods
------------------------------
-- | The canonical projection for a ring to the quotient.
proj ∷ EuclideanDomain a ⇒ a → a → Quotient a
proj m x = Quotient {modulus = Just m, element = x `mod` m}

-- | The associated function on the quotient. Definitely not guaranteed to be well defined (ie may depend on the choice of coset representative).
liftQ ∷ EuclideanDomain a ⇒ (a → a) → Quotient a → Quotient a
liftQ f (Quotient Nothing x) = Quotient Nothing $ f x
liftQ f (Quotient (Just m) x) = proj m $ f x

-- | The associated binary function defined on the quotient. Definitely not guaranteed to be well defined (ie may depend on the choice of coset representative).
liftQ2' ∷ (EuclideanDomain a, Eq a) ⇒ (a → a → b) → Quotient a → Quotient a → b
liftQ2' f (Quotient Nothing x)  (Quotient Nothing y)  = f x y
liftQ2' f (Quotient Nothing x)  (Quotient (Just m) y) = f (x `mod` m) y
liftQ2' f (Quotient (Just m) x) (Quotient Nothing y)  = f x (y `mod` m)
liftQ2' f (Quotient (Just m) x) (Quotient (Just m') y)
  | m == m' = f x y
  | otherwise = error "non matching moduli"

-- | The associated binary function defined on the quotient. Definitely not guaranteed to be well defined (ie may depend on the choice of coset representative).
liftQ2 ∷ (EuclideanDomain a, Eq a) ⇒ (a → a → a) → Quotient a → Quotient a → Quotient a
liftQ2 f (Quotient Nothing x)  (Quotient Nothing y)  =  Quotient Nothing $ f x y
liftQ2 f (Quotient Nothing x)  (Quotient (Just m) y) = Quotient (Just m) $ f (x `mod` m) y
liftQ2 f (Quotient (Just m) x) (Quotient Nothing y)  = Quotient (Just m) $ f x (y `mod` m)
liftQ2 f (Quotient (Just m) x) (Quotient (Just m') y)
  | m == m' = proj m $ f x y
  | otherwise = error "non matching moduli"

------------------------------
---- Instances
------------------------------

instance Show a ⇒ Show (Quotient a) where
  show (Quotient Nothing x) = P.show x
  show (Quotient (Just m) x) = P.show x ++ " (mod " ++ P.show m ++ ")"

instance (EuclideanDomain a, Eq a, Approx a) ⇒ Approx (Quotient a) where
  (=~) = liftQ2' (=~)

instance (EuclideanDomain a, Eq a) ⇒ Eq (Quotient a) where
  (==) = liftQ2' (==)

instance (EuclideanDomain a, Eq a) ⇒ Monoid (Quotient a) where
  mempty = Quotient Nothing mempty
  mappend = liftQ2 mappend

instance (EuclideanDomain a, Eq a) ⇒ Group (Quotient a) where
  negate = liftQ negate

instance (EuclideanDomain a, Eq a) ⇒ Abelian (Quotient a)

instance (EuclideanDomain a, Eq a) ⇒ Ring (Quotient a) where
  one = Quotient Nothing one
  (*) = liftQ2 (*)

instance (EuclideanDomain a, Eq a) ⇒ CRing (Quotient a)

instance (Derivation a, EuclideanDomain a, Eq a) ⇒ Derivation (Quotient  a) where
  derive = liftQ derive
